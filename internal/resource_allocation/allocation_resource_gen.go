// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_allocation

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func AllocationResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^netbox\\.eda\\.nokia\\.com/v1alpha1$"), ""),
				},
				Default: stringdefault.StaticString("netbox.eda.nokia.com/v1alpha1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Allocation$"), ""),
				},
				Default: stringdefault.StaticString("Allocation"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Allocation",
				MarkdownDescription: "name of the Allocation",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "A short description of the Allocation resource",
						MarkdownDescription: "A short description of the Allocation resource",
					},
					"enabled": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "If true the Allocation is enabled.",
						MarkdownDescription: "If true the Allocation is enabled.",
						Default:             booldefault.StaticBool(true),
					},
					"instance": schema.StringAttribute{
						Required:            true,
						Description:         "Netbox instance reference",
						MarkdownDescription: "Netbox instance reference",
					},
					"subnet_length": schema.Int64Attribute{
						Optional:            true,
						Description:         "Prefix length when the type is subnet",
						MarkdownDescription: "Prefix length when the type is subnet",
					},
					"tags": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "List of tags that must be included in the IPPrefix/ASNRange received from NetBox\nfor this allocation to be applied.",
						MarkdownDescription: "List of tags that must be included in the IPPrefix/ASNRange received from NetBox\nfor this allocation to be applied.",
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Description:         "The allocation type: one of ip-address, subnet, ip-in-subnet, vlan or asn",
						MarkdownDescription: "The allocation type: one of ip-address, subnet, ip-in-subnet, vlan or asn",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"ip-address",
								"subnet",
								"ip-in-subnet",
								"asn",
								"vlan",
							),
						},
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "AllocationSpec defines the desired state of Allocation",
				MarkdownDescription: "AllocationSpec defines the desired state of Allocation",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"last_event": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"last_event_status": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"last_event_time": schema.StringAttribute{
						Optional: true,
						Computed: true,
					},
					"matched_asn_ranges": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"end": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"id": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"name": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"rir": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"start": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"tags": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
								},
							},
							CustomType: MatchedAsnRangesType{
								ObjectType: types.ObjectType{
									AttrTypes: MatchedAsnRangesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"matched_prefixes": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"is_container": schema.BoolAttribute{
									Optional: true,
									Computed: true,
								},
								"prefix": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"tags": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
								},
							},
							CustomType: MatchedPrefixesType{
								ObjectType: types.ObjectType{
									AttrTypes: MatchedPrefixesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
					"matched_vlan_groups": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.Int64Attribute{
									Optional: true,
									Computed: true,
								},
								"name": schema.StringAttribute{
									Optional: true,
									Computed: true,
								},
								"ranges": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"end": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
											"start": schema.Int64Attribute{
												Optional: true,
												Computed: true,
											},
										},
										CustomType: RangesType{
											ObjectType: types.ObjectType{
												AttrTypes: RangesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional: true,
									Computed: true,
								},
								"tags": schema.ListAttribute{
									ElementType: types.StringType,
									Optional:    true,
									Computed:    true,
								},
							},
							CustomType: MatchedVlanGroupsType{
								ObjectType: types.ObjectType{
									AttrTypes: MatchedVlanGroupsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "AllocationStatus defines the observed state of Allocation",
				MarkdownDescription: "AllocationStatus defines the observed state of Allocation",
			},
		},
	}
}

type AllocationModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	instanceAttribute, ok := attributes["instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance is missing from object`)

		return nil, diags
	}

	instanceVal, ok := instanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance expected to be basetypes.StringValue, was: %T`, instanceAttribute))
	}

	subnetLengthAttribute, ok := attributes["subnet_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_length is missing from object`)

		return nil, diags
	}

	subnetLengthVal, ok := subnetLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_length expected to be basetypes.Int64Value, was: %T`, subnetLengthAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Description:  descriptionVal,
		Enabled:      enabledVal,
		Instance:     instanceVal,
		SubnetLength: subnetLengthVal,
		Tags:         tagsVal,
		SpecType:     typeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	instanceAttribute, ok := attributes["instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	instanceVal, ok := instanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance expected to be basetypes.StringValue, was: %T`, instanceAttribute))
	}

	subnetLengthAttribute, ok := attributes["subnet_length"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_length is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	subnetLengthVal, ok := subnetLengthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_length expected to be basetypes.Int64Value, was: %T`, subnetLengthAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Description:  descriptionVal,
		Enabled:      enabledVal,
		Instance:     instanceVal,
		SubnetLength: subnetLengthVal,
		Tags:         tagsVal,
		SpecType:     typeVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Description  basetypes.StringValue `tfsdk:"description"`
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	Instance     basetypes.StringValue `tfsdk:"instance"`
	SubnetLength basetypes.Int64Value  `tfsdk:"subnet_length"`
	Tags         basetypes.ListValue   `tfsdk:"tags"`
	SpecType     basetypes.StringValue `tfsdk:"type"`
	state        attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_length"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance"] = val

		val, err = v.SubnetLength.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_length"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"description":   basetypes.StringType{},
			"enabled":       basetypes.BoolType{},
			"instance":      basetypes.StringType{},
			"subnet_length": basetypes.Int64Type{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
			"type": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"description":   basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"instance":      basetypes.StringType{},
		"subnet_length": basetypes.Int64Type{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":   v.Description,
			"enabled":       v.Enabled,
			"instance":      v.Instance,
			"subnet_length": v.SubnetLength,
			"tags":          tagsVal,
			"type":          v.SpecType,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Instance.Equal(other.Instance) {
		return false
	}

	if !v.SubnetLength.Equal(other.SubnetLength) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":   basetypes.StringType{},
		"enabled":       basetypes.BoolType{},
		"instance":      basetypes.StringType{},
		"subnet_length": basetypes.Int64Type{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return nil, diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastEventStatusAttribute, ok := attributes["last_event_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event_status is missing from object`)

		return nil, diags
	}

	lastEventStatusVal, ok := lastEventStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event_status expected to be basetypes.StringValue, was: %T`, lastEventStatusAttribute))
	}

	lastEventTimeAttribute, ok := attributes["last_event_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event_time is missing from object`)

		return nil, diags
	}

	lastEventTimeVal, ok := lastEventTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event_time expected to be basetypes.StringValue, was: %T`, lastEventTimeAttribute))
	}

	matchedAsnRangesAttribute, ok := attributes["matched_asn_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_asn_ranges is missing from object`)

		return nil, diags
	}

	matchedAsnRangesVal, ok := matchedAsnRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_asn_ranges expected to be basetypes.ListValue, was: %T`, matchedAsnRangesAttribute))
	}

	matchedPrefixesAttribute, ok := attributes["matched_prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_prefixes is missing from object`)

		return nil, diags
	}

	matchedPrefixesVal, ok := matchedPrefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_prefixes expected to be basetypes.ListValue, was: %T`, matchedPrefixesAttribute))
	}

	matchedVlanGroupsAttribute, ok := attributes["matched_vlan_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_vlan_groups is missing from object`)

		return nil, diags
	}

	matchedVlanGroupsVal, ok := matchedVlanGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_vlan_groups expected to be basetypes.ListValue, was: %T`, matchedVlanGroupsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		LastEvent:         lastEventVal,
		LastEventStatus:   lastEventStatusVal,
		LastEventTime:     lastEventTimeVal,
		MatchedAsnRanges:  matchedAsnRangesVal,
		MatchedPrefixes:   matchedPrefixesVal,
		MatchedVlanGroups: matchedVlanGroupsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	lastEventAttribute, ok := attributes["last_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastEventVal, ok := lastEventAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event expected to be basetypes.StringValue, was: %T`, lastEventAttribute))
	}

	lastEventStatusAttribute, ok := attributes["last_event_status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event_status is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastEventStatusVal, ok := lastEventStatusAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event_status expected to be basetypes.StringValue, was: %T`, lastEventStatusAttribute))
	}

	lastEventTimeAttribute, ok := attributes["last_event_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_event_time is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastEventTimeVal, ok := lastEventTimeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_event_time expected to be basetypes.StringValue, was: %T`, lastEventTimeAttribute))
	}

	matchedAsnRangesAttribute, ok := attributes["matched_asn_ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_asn_ranges is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	matchedAsnRangesVal, ok := matchedAsnRangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_asn_ranges expected to be basetypes.ListValue, was: %T`, matchedAsnRangesAttribute))
	}

	matchedPrefixesAttribute, ok := attributes["matched_prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_prefixes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	matchedPrefixesVal, ok := matchedPrefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_prefixes expected to be basetypes.ListValue, was: %T`, matchedPrefixesAttribute))
	}

	matchedVlanGroupsAttribute, ok := attributes["matched_vlan_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`matched_vlan_groups is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	matchedVlanGroupsVal, ok := matchedVlanGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`matched_vlan_groups expected to be basetypes.ListValue, was: %T`, matchedVlanGroupsAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		LastEvent:         lastEventVal,
		LastEventStatus:   lastEventStatusVal,
		LastEventTime:     lastEventTimeVal,
		MatchedAsnRanges:  matchedAsnRangesVal,
		MatchedPrefixes:   matchedPrefixesVal,
		MatchedVlanGroups: matchedVlanGroupsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	LastEvent         basetypes.StringValue `tfsdk:"last_event"`
	LastEventStatus   basetypes.StringValue `tfsdk:"last_event_status"`
	LastEventTime     basetypes.StringValue `tfsdk:"last_event_time"`
	MatchedAsnRanges  basetypes.ListValue   `tfsdk:"matched_asn_ranges"`
	MatchedPrefixes   basetypes.ListValue   `tfsdk:"matched_prefixes"`
	MatchedVlanGroups basetypes.ListValue   `tfsdk:"matched_vlan_groups"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["last_event"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_event_status"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_event_time"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["matched_asn_ranges"] = basetypes.ListType{
		ElemType: MatchedAsnRangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["matched_prefixes"] = basetypes.ListType{
		ElemType: MatchedPrefixesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["matched_vlan_groups"] = basetypes.ListType{
		ElemType: MatchedVlanGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.LastEvent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_event"] = val

		val, err = v.LastEventStatus.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_event_status"] = val

		val, err = v.LastEventTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_event_time"] = val

		val, err = v.MatchedAsnRanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matched_asn_ranges"] = val

		val, err = v.MatchedPrefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matched_prefixes"] = val

		val, err = v.MatchedVlanGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["matched_vlan_groups"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	matchedAsnRanges := types.ListValueMust(
		MatchedAsnRangesType{
			basetypes.ObjectType{
				AttrTypes: MatchedAsnRangesValue{}.AttributeTypes(ctx),
			},
		},
		v.MatchedAsnRanges.Elements(),
	)

	if v.MatchedAsnRanges.IsNull() {
		matchedAsnRanges = types.ListNull(
			MatchedAsnRangesType{
				basetypes.ObjectType{
					AttrTypes: MatchedAsnRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MatchedAsnRanges.IsUnknown() {
		matchedAsnRanges = types.ListUnknown(
			MatchedAsnRangesType{
				basetypes.ObjectType{
					AttrTypes: MatchedAsnRangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	matchedPrefixes := types.ListValueMust(
		MatchedPrefixesType{
			basetypes.ObjectType{
				AttrTypes: MatchedPrefixesValue{}.AttributeTypes(ctx),
			},
		},
		v.MatchedPrefixes.Elements(),
	)

	if v.MatchedPrefixes.IsNull() {
		matchedPrefixes = types.ListNull(
			MatchedPrefixesType{
				basetypes.ObjectType{
					AttrTypes: MatchedPrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MatchedPrefixes.IsUnknown() {
		matchedPrefixes = types.ListUnknown(
			MatchedPrefixesType{
				basetypes.ObjectType{
					AttrTypes: MatchedPrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	matchedVlanGroups := types.ListValueMust(
		MatchedVlanGroupsType{
			basetypes.ObjectType{
				AttrTypes: MatchedVlanGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.MatchedVlanGroups.Elements(),
	)

	if v.MatchedVlanGroups.IsNull() {
		matchedVlanGroups = types.ListNull(
			MatchedVlanGroupsType{
				basetypes.ObjectType{
					AttrTypes: MatchedVlanGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.MatchedVlanGroups.IsUnknown() {
		matchedVlanGroups = types.ListUnknown(
			MatchedVlanGroupsType{
				basetypes.ObjectType{
					AttrTypes: MatchedVlanGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"last_event":        basetypes.StringType{},
		"last_event_status": basetypes.StringType{},
		"last_event_time":   basetypes.StringType{},
		"matched_asn_ranges": basetypes.ListType{
			ElemType: MatchedAsnRangesValue{}.Type(ctx),
		},
		"matched_prefixes": basetypes.ListType{
			ElemType: MatchedPrefixesValue{}.Type(ctx),
		},
		"matched_vlan_groups": basetypes.ListType{
			ElemType: MatchedVlanGroupsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"last_event":          v.LastEvent,
			"last_event_status":   v.LastEventStatus,
			"last_event_time":     v.LastEventTime,
			"matched_asn_ranges":  matchedAsnRanges,
			"matched_prefixes":    matchedPrefixes,
			"matched_vlan_groups": matchedVlanGroups,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LastEvent.Equal(other.LastEvent) {
		return false
	}

	if !v.LastEventStatus.Equal(other.LastEventStatus) {
		return false
	}

	if !v.LastEventTime.Equal(other.LastEventTime) {
		return false
	}

	if !v.MatchedAsnRanges.Equal(other.MatchedAsnRanges) {
		return false
	}

	if !v.MatchedPrefixes.Equal(other.MatchedPrefixes) {
		return false
	}

	if !v.MatchedVlanGroups.Equal(other.MatchedVlanGroups) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"last_event":        basetypes.StringType{},
		"last_event_status": basetypes.StringType{},
		"last_event_time":   basetypes.StringType{},
		"matched_asn_ranges": basetypes.ListType{
			ElemType: MatchedAsnRangesValue{}.Type(ctx),
		},
		"matched_prefixes": basetypes.ListType{
			ElemType: MatchedPrefixesValue{}.Type(ctx),
		},
		"matched_vlan_groups": basetypes.ListType{
			ElemType: MatchedVlanGroupsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MatchedAsnRangesType{}

type MatchedAsnRangesType struct {
	basetypes.ObjectType
}

func (t MatchedAsnRangesType) Equal(o attr.Type) bool {
	other, ok := o.(MatchedAsnRangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchedAsnRangesType) String() string {
	return "MatchedAsnRangesType"
}

func (t MatchedAsnRangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return nil, diags
	}

	endVal, ok := endAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.Int64Value, was: %T`, endAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rirAttribute, ok := attributes["rir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rir is missing from object`)

		return nil, diags
	}

	rirVal, ok := rirAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rir expected to be basetypes.Int64Value, was: %T`, rirAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.Int64Value, was: %T`, startAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchedAsnRangesValue{
		End:   endVal,
		Id:    idVal,
		Name:  nameVal,
		Rir:   rirVal,
		Start: startVal,
		Tags:  tagsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMatchedAsnRangesValueNull() MatchedAsnRangesValue {
	return MatchedAsnRangesValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchedAsnRangesValueUnknown() MatchedAsnRangesValue {
	return MatchedAsnRangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchedAsnRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchedAsnRangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchedAsnRangesValue Attribute Value",
				"While creating a MatchedAsnRangesValue value, a missing attribute value was detected. "+
					"A MatchedAsnRangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedAsnRangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchedAsnRangesValue Attribute Type",
				"While creating a MatchedAsnRangesValue value, an invalid attribute value was detected. "+
					"A MatchedAsnRangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedAsnRangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchedAsnRangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchedAsnRangesValue Attribute Value",
				"While creating a MatchedAsnRangesValue value, an extra attribute value was detected. "+
					"A MatchedAsnRangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchedAsnRangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchedAsnRangesValueUnknown(), diags
	}

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	endVal, ok := endAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.Int64Value, was: %T`, endAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rirAttribute, ok := attributes["rir"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rir is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	rirVal, ok := rirAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rir expected to be basetypes.Int64Value, was: %T`, rirAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.Int64Value, was: %T`, startAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMatchedAsnRangesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewMatchedAsnRangesValueUnknown(), diags
	}

	return MatchedAsnRangesValue{
		End:   endVal,
		Id:    idVal,
		Name:  nameVal,
		Rir:   rirVal,
		Start: startVal,
		Tags:  tagsVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewMatchedAsnRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchedAsnRangesValue {
	object, diags := NewMatchedAsnRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchedAsnRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchedAsnRangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchedAsnRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchedAsnRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchedAsnRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchedAsnRangesValueMust(MatchedAsnRangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchedAsnRangesType) ValueType(ctx context.Context) attr.Value {
	return MatchedAsnRangesValue{}
}

var _ basetypes.ObjectValuable = MatchedAsnRangesValue{}

type MatchedAsnRangesValue struct {
	End   basetypes.Int64Value  `tfsdk:"end"`
	Id    basetypes.Int64Value  `tfsdk:"id"`
	Name  basetypes.StringValue `tfsdk:"name"`
	Rir   basetypes.Int64Value  `tfsdk:"rir"`
	Start basetypes.Int64Value  `tfsdk:"start"`
	Tags  basetypes.ListValue   `tfsdk:"tags"`
	state attr.ValueState
}

func (v MatchedAsnRangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["end"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rir"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.End.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Rir.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rir"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchedAsnRangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchedAsnRangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchedAsnRangesValue) String() string {
	return "MatchedAsnRangesValue"
}

func (v MatchedAsnRangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"end":   basetypes.Int64Type{},
			"id":    basetypes.Int64Type{},
			"name":  basetypes.StringType{},
			"rir":   basetypes.Int64Type{},
			"start": basetypes.Int64Type{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"end":   basetypes.Int64Type{},
		"id":    basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"rir":   basetypes.Int64Type{},
		"start": basetypes.Int64Type{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"end":   v.End,
			"id":    v.Id,
			"name":  v.Name,
			"rir":   v.Rir,
			"start": v.Start,
			"tags":  tagsVal,
		})

	return objVal, diags
}

func (v MatchedAsnRangesValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchedAsnRangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.End.Equal(other.End) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Rir.Equal(other.Rir) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v MatchedAsnRangesValue) Type(ctx context.Context) attr.Type {
	return MatchedAsnRangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchedAsnRangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"end":   basetypes.Int64Type{},
		"id":    basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"rir":   basetypes.Int64Type{},
		"start": basetypes.Int64Type{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MatchedPrefixesType{}

type MatchedPrefixesType struct {
	basetypes.ObjectType
}

func (t MatchedPrefixesType) Equal(o attr.Type) bool {
	other, ok := o.(MatchedPrefixesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchedPrefixesType) String() string {
	return "MatchedPrefixesType"
}

func (t MatchedPrefixesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isContainerAttribute, ok := attributes["is_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_container is missing from object`)

		return nil, diags
	}

	isContainerVal, ok := isContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_container expected to be basetypes.BoolValue, was: %T`, isContainerAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchedPrefixesValue{
		Id:          idVal,
		IsContainer: isContainerVal,
		Prefix:      prefixVal,
		Tags:        tagsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMatchedPrefixesValueNull() MatchedPrefixesValue {
	return MatchedPrefixesValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchedPrefixesValueUnknown() MatchedPrefixesValue {
	return MatchedPrefixesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchedPrefixesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchedPrefixesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchedPrefixesValue Attribute Value",
				"While creating a MatchedPrefixesValue value, a missing attribute value was detected. "+
					"A MatchedPrefixesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedPrefixesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchedPrefixesValue Attribute Type",
				"While creating a MatchedPrefixesValue value, an invalid attribute value was detected. "+
					"A MatchedPrefixesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedPrefixesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchedPrefixesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchedPrefixesValue Attribute Value",
				"While creating a MatchedPrefixesValue value, an extra attribute value was detected. "+
					"A MatchedPrefixesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchedPrefixesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchedPrefixesValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewMatchedPrefixesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isContainerAttribute, ok := attributes["is_container"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_container is missing from object`)

		return NewMatchedPrefixesValueUnknown(), diags
	}

	isContainerVal, ok := isContainerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_container expected to be basetypes.BoolValue, was: %T`, isContainerAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewMatchedPrefixesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMatchedPrefixesValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewMatchedPrefixesValueUnknown(), diags
	}

	return MatchedPrefixesValue{
		Id:          idVal,
		IsContainer: isContainerVal,
		Prefix:      prefixVal,
		Tags:        tagsVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMatchedPrefixesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchedPrefixesValue {
	object, diags := NewMatchedPrefixesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchedPrefixesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchedPrefixesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchedPrefixesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchedPrefixesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchedPrefixesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchedPrefixesValueMust(MatchedPrefixesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchedPrefixesType) ValueType(ctx context.Context) attr.Value {
	return MatchedPrefixesValue{}
}

var _ basetypes.ObjectValuable = MatchedPrefixesValue{}

type MatchedPrefixesValue struct {
	Id          basetypes.Int64Value  `tfsdk:"id"`
	IsContainer basetypes.BoolValue   `tfsdk:"is_container"`
	Prefix      basetypes.StringValue `tfsdk:"prefix"`
	Tags        basetypes.ListValue   `tfsdk:"tags"`
	state       attr.ValueState
}

func (v MatchedPrefixesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_container"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IsContainer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_container"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchedPrefixesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchedPrefixesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchedPrefixesValue) String() string {
	return "MatchedPrefixesValue"
}

func (v MatchedPrefixesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"id":           basetypes.Int64Type{},
			"is_container": basetypes.BoolType{},
			"prefix":       basetypes.StringType{},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"id":           basetypes.Int64Type{},
		"is_container": basetypes.BoolType{},
		"prefix":       basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":           v.Id,
			"is_container": v.IsContainer,
			"prefix":       v.Prefix,
			"tags":         tagsVal,
		})

	return objVal, diags
}

func (v MatchedPrefixesValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchedPrefixesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IsContainer.Equal(other.IsContainer) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v MatchedPrefixesValue) Type(ctx context.Context) attr.Type {
	return MatchedPrefixesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchedPrefixesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":           basetypes.Int64Type{},
		"is_container": basetypes.BoolType{},
		"prefix":       basetypes.StringType{},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MatchedVlanGroupsType{}

type MatchedVlanGroupsType struct {
	basetypes.ObjectType
}

func (t MatchedVlanGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(MatchedVlanGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchedVlanGroupsType) String() string {
	return "MatchedVlanGroupsType"
}

func (t MatchedVlanGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rangesAttribute, ok := attributes["ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ranges is missing from object`)

		return nil, diags
	}

	rangesVal, ok := rangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ranges expected to be basetypes.ListValue, was: %T`, rangesAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchedVlanGroupsValue{
		Id:     idVal,
		Name:   nameVal,
		Ranges: rangesVal,
		Tags:   tagsVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMatchedVlanGroupsValueNull() MatchedVlanGroupsValue {
	return MatchedVlanGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchedVlanGroupsValueUnknown() MatchedVlanGroupsValue {
	return MatchedVlanGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchedVlanGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchedVlanGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchedVlanGroupsValue Attribute Value",
				"While creating a MatchedVlanGroupsValue value, a missing attribute value was detected. "+
					"A MatchedVlanGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedVlanGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchedVlanGroupsValue Attribute Type",
				"While creating a MatchedVlanGroupsValue value, an invalid attribute value was detected. "+
					"A MatchedVlanGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchedVlanGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchedVlanGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchedVlanGroupsValue Attribute Value",
				"While creating a MatchedVlanGroupsValue value, an extra attribute value was detected. "+
					"A MatchedVlanGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchedVlanGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rangesAttribute, ok := attributes["ranges"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ranges is missing from object`)

		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	rangesVal, ok := rangesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ranges expected to be basetypes.ListValue, was: %T`, rangesAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ListValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewMatchedVlanGroupsValueUnknown(), diags
	}

	return MatchedVlanGroupsValue{
		Id:     idVal,
		Name:   nameVal,
		Ranges: rangesVal,
		Tags:   tagsVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewMatchedVlanGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchedVlanGroupsValue {
	object, diags := NewMatchedVlanGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchedVlanGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchedVlanGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchedVlanGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchedVlanGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchedVlanGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchedVlanGroupsValueMust(MatchedVlanGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchedVlanGroupsType) ValueType(ctx context.Context) attr.Value {
	return MatchedVlanGroupsValue{}
}

var _ basetypes.ObjectValuable = MatchedVlanGroupsValue{}

type MatchedVlanGroupsValue struct {
	Id     basetypes.Int64Value  `tfsdk:"id"`
	Name   basetypes.StringValue `tfsdk:"name"`
	Ranges basetypes.ListValue   `tfsdk:"ranges"`
	Tags   basetypes.ListValue   `tfsdk:"tags"`
	state  attr.ValueState
}

func (v MatchedVlanGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ranges"] = basetypes.ListType{
		ElemType: RangesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Ranges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ranges"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchedVlanGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchedVlanGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchedVlanGroupsValue) String() string {
	return "MatchedVlanGroupsValue"
}

func (v MatchedVlanGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ranges := types.ListValueMust(
		RangesType{
			basetypes.ObjectType{
				AttrTypes: RangesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ranges.Elements(),
	)

	if v.Ranges.IsNull() {
		ranges = types.ListNull(
			RangesType{
				basetypes.ObjectType{
					AttrTypes: RangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ranges.IsUnknown() {
		ranges = types.ListUnknown(
			RangesType{
				basetypes.ObjectType{
					AttrTypes: RangesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var tagsVal basetypes.ListValue
	switch {
	case v.Tags.IsUnknown():
		tagsVal = types.ListUnknown(types.StringType)
	case v.Tags.IsNull():
		tagsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		tagsVal, d = types.ListValue(types.StringType, v.Tags.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"id":   basetypes.Int64Type{},
			"name": basetypes.StringType{},
			"ranges": basetypes.ListType{
				ElemType: RangesValue{}.Type(ctx),
			},
			"tags": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"id":   basetypes.Int64Type{},
		"name": basetypes.StringType{},
		"ranges": basetypes.ListType{
			ElemType: RangesValue{}.Type(ctx),
		},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"id":     v.Id,
			"name":   v.Name,
			"ranges": ranges,
			"tags":   tagsVal,
		})

	return objVal, diags
}

func (v MatchedVlanGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchedVlanGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Ranges.Equal(other.Ranges) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v MatchedVlanGroupsValue) Type(ctx context.Context) attr.Type {
	return MatchedVlanGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchedVlanGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"id":   basetypes.Int64Type{},
		"name": basetypes.StringType{},
		"ranges": basetypes.ListType{
			ElemType: RangesValue{}.Type(ctx),
		},
		"tags": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = RangesType{}

type RangesType struct {
	basetypes.ObjectType
}

func (t RangesType) Equal(o attr.Type) bool {
	other, ok := o.(RangesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RangesType) String() string {
	return "RangesType"
}

func (t RangesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return nil, diags
	}

	endVal, ok := endAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.Int64Value, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return nil, diags
	}

	startVal, ok := startAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.Int64Value, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RangesValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRangesValueNull() RangesValue {
	return RangesValue{
		state: attr.ValueStateNull,
	}
}

func NewRangesValueUnknown() RangesValue {
	return RangesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRangesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RangesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RangesValue Attribute Value",
				"While creating a RangesValue value, a missing attribute value was detected. "+
					"A RangesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RangesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RangesValue Attribute Type",
				"While creating a RangesValue value, an invalid attribute value was detected. "+
					"A RangesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RangesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RangesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RangesValue Attribute Value",
				"While creating a RangesValue value, an extra attribute value was detected. "+
					"A RangesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RangesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRangesValueUnknown(), diags
	}

	endAttribute, ok := attributes["end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end is missing from object`)

		return NewRangesValueUnknown(), diags
	}

	endVal, ok := endAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end expected to be basetypes.Int64Value, was: %T`, endAttribute))
	}

	startAttribute, ok := attributes["start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start is missing from object`)

		return NewRangesValueUnknown(), diags
	}

	startVal, ok := startAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start expected to be basetypes.Int64Value, was: %T`, startAttribute))
	}

	if diags.HasError() {
		return NewRangesValueUnknown(), diags
	}

	return RangesValue{
		End:   endVal,
		Start: startVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRangesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RangesValue {
	object, diags := NewRangesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRangesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RangesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRangesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRangesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRangesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRangesValueMust(RangesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RangesType) ValueType(ctx context.Context) attr.Value {
	return RangesValue{}
}

var _ basetypes.ObjectValuable = RangesValue{}

type RangesValue struct {
	End   basetypes.Int64Value `tfsdk:"end"`
	Start basetypes.Int64Value `tfsdk:"start"`
	state attr.ValueState
}

func (v RangesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["end"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["start"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.End.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end"] = val

		val, err = v.Start.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RangesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RangesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RangesValue) String() string {
	return "RangesValue"
}

func (v RangesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"end":   basetypes.Int64Type{},
		"start": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"end":   v.End,
			"start": v.Start,
		})

	return objVal, diags
}

func (v RangesValue) Equal(o attr.Value) bool {
	other, ok := o.(RangesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.End.Equal(other.End) {
		return false
	}

	if !v.Start.Equal(other.Start) {
		return false
	}

	return true
}

func (v RangesValue) Type(ctx context.Context) attr.Type {
	return RangesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RangesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"end":   basetypes.Int64Type{},
		"start": basetypes.Int64Type{},
	}
}
